# -*- coding: utf-8 -*-

"""1D(theta)_HT.ipynb
 
Automatically generated by Colab.
 
Original file is located at
https://colab.research.google.com/drive/1TvC4Zemarakd0q62BHjYiCqzEABTQMgN

"""
 
import numpy as np

from scipy.sparse import diags

from scipy.sparse.linalg import spsolve

import matplotlib.pyplot as plt
 
# Costanti fisiche universali

q_e = -1.6e-19        # Carica dell'elettrone (C)

q_i = 1.6e-19         # Carica dello ione (C) (si considerano solo ioni singolarmente ionizzati)

m_e = 9.11e-31        # Massa dell'elettrone (kg)

m_i = 2.18e-26        # Massa dello ione (kg) (ipotizzando Xenon)

epsilon0 = 8.85e-12   # Permittività del vuoto (F/m)

kB = 1.38-23          # costante di Boltzmann (JK)

epsktoq2 = 4.77e3     # epsilon0*kB/q^2

sqrt_ktome = 3892     # sqrt(kB/me)

sqrt_ktomi = 25.16    # sqrt(kB/mi)
 
# Parametri fisici (sistema unità di misura SI) e numerici della simulazione

Ly = 0.005             # Lunghezza del dominio azimuthale (m)

Ny = 200              # Numero di celle

dt = 2e-11            # Passo temporale (s)

Nt = 100              # Numero di passi temporali

nppc = 50            # Numero di particelle per cella

dens0 = 1e18          # Densità di plasma iniziale media

Te0 = 232000          # Temperatura elettronica (K)

Ti0 = 11600           # Temperatura ionica (K)

Ex = 20000            # Campo elettrico accelerante assiale (V/m)

Bz = 0.01             # Campo magnetico radiale (T)
 
# Grandezze derivate
 
# Numero di particelle per specie

n_particles = nppc * Ny

# Dimensione della cella

dy = Ly / Ny

# Peso della macroparticella

w = Ly * dens0 / n_particles # Le cariche sono in realtà cariche per unità di superficie

# Tempo totale di simulazione

Ttot = Nt * dt

# Criterio leapfrog

Delta_t = 0.2 * (2 * np.pi / np.sqrt(q_e**2 * dens0/ (epsilon0 * m_e)))

# Lunghezza di Debye

l_debye = np.sqrt(epsktoq2 * Te0 / dens0)
 
print(f"Tempo totale: {Ttot} s")

print(f"Leapfrod_dt: {Delta_t} s --- Timestep: {dt} s")
 
print(f"cell size: {dy} m --- Lunghezza di Debye: {l_debye} m")
 
print(f"w: {w} C/m^2")
 
# Inizializzazione delle particelle
 
# elettroni

y_e = np.random.rand(n_particles) * Ly     # Posizioni iniziali degli elettroni uniformemente distribuiti in [0,Lx]

v_e = np.random.normal(0, sqrt_ktome*np.sqrt(Te0), (n_particles,3)) # Distribuzione Maxwelliana delle velocità
 
# ioni

y_i = np.random.rand(n_particles) * Ly     # Posizioni iniziali degli elettroni uniformemente distribuiti in [0,L]

v_i = np.random.normal(0, sqrt_ktomi*np.sqrt(Ti0), (n_particles,3))
 
print(f"v_e: {v_e}")

print(f"v_i: {v_i}")
 
# istogramma del modulo della velocità elettronica

plt.hist(np.linalg.norm(v_e, axis=1), bins=30, density=True, alpha=0.5, label='Elettrone')

plt.xlabel('Modulo della velocità (m/s)')

plt.ylabel('Densità di probabilità')

plt.show()

plt.hist(np.linalg.norm(v_i, axis=1), bins=30, density=True, alpha=0.5, label='Ione')

plt.xlabel('Modulo della velocità (m/s)')

plt.ylabel('Densità di probabilità')

plt.show()
 
# Griglia per i campi

rho = np.zeros(Ny)  # Densità di carica

phi = np.zeros(Ny)  # Potenziale elettrico

Eyg = np.zeros(Ny)  # Campo elettrico

# Matrice per salvare il campo elettrico nel tempo

Eyg_history = np.zeros((Nt, Ny))
 
# Matrice tridiagonale Equazione di Poisson:

# 1*phi(i-1)-2*phi(i)+1*phi(i+1)=-rho*dx**2/epsilon0
 
diagonals = [np.full(Ny, -2),              # Diagonale principale

             np.full(Ny - 1, 1),           # Diagonale sopra

             np.full(Ny - 1, 1)]           # Diagonale sotto

# Aggiungere le condizioni periodiche

A = diags(diagonals, offsets=[0, 1, -1], shape=(Ny, Ny), format='csc')

A[0, -1] = 1  # Collegamento tra primo e ultimo nodo

A[-1, 0] = 1  # Collegamento tra ultimo e primo nodo
 
# Scatter: Funzioni di interpolazione NGP
 
def deposit_charge(y, q, Ny, dy):

  rho = np.zeros(Ny) # azzeramento densità di carica sui punti di griglia

  for i in range(len(y)):

    j = int(y[i] / dy)

    rho[j] += w*q / dy

  return rho
 
# Field: Solutore Poisson metodo diretto di inversione matrice
 
def solve_poisson(A, rho, dy, epsilon0):

  # Termine sorgente

  b = -rho / epsilon0 * dy**2

  phi = spsolve(A, b)

  # reference potential

  phi -= phi[0]

  return phi
 
# Push: Solutore EoM

# Metodo di Leapfrog-Buneman-Boris per aggiornare le particelle
 
def boris_LF(y, v, q, m, Eyg, Ex, Bz, dt, dy, Ny, Ly):

  for i in range(len(y)):

    # Indice della griglia

    j = int(y[i] / dy)

    # Campo elettrico locale (funzione interpolante NGP)

    Ep = np.array([Ex, Eyg[j], 0])

    # Campo magnetico locale (funzione interpolante NGP)

    Bp = np.array([0, 0, Bz])

    const1 = q*dt/(2*m)

    t = const1*Bp

    const2 = 2/(1+np.abs(t)**2)

    # Updating speed

    ## Adding half of the electric acceleration

    va = v[i,:] + const1*Ep

    ## Rotation of speed around B

    vb = va + np.cross(va,t)

    vc = va + const2*np.cross(vb,t)

    ## Adding second half of the electric acceleration

    v[i,:] = vc + const1*Ep

    # Aggiornamento della posizione azimuthale

    y[i] += v[i,1] * dt

    # condizioni periodiche

    if y[i] < 0:

      y[i] += Ly

    if y[i] > Ly:

      y[i] -= Ly

  return y, v
 
# Loops PIC principale della simulazione
 
for t in range(Nt):

    # Deposizione della carica sulla griglia

    rho_e = deposit_charge(y_e, q_e, Ny, dy)

    rho_i = deposit_charge(y_i, q_i, Ny, dy)

    rho = rho_e + rho_i
 
    # Calcolo del campo elettrico

    phi = solve_poisson(A, rho, dy, epsilon0)

    Eyg = -np.gradient(phi, dy)

    # Salvataggio del campo elettrico

    Eyg_history[t, :] = Eyg
 
    # Aggiornamento posizione e velocità delle particelle

    boris_LF(y_e, v_e, q_e, m_e, Eyg, Ex, Bz, dt, dy, Ny, Ly)

    boris_LF(y_i, v_i, q_i, m_i, Eyg, Ex, Bz, dt, dy, Ny, Ly)
 
    # Visualizzazione dei risultati ogni 100 passi

    if t % 10 == 0:

        plt.figure(figsize=(10, 4))

        plt.plot(np.linspace(0, Ly, Ny), rho_e/q_e, label="dens_e (m^-3)")

#        plt.plot(np.linspace(0, Ly, Ny), phi, label="phi (V)")

        plt.title(f"Tempo: {t * dt:.2e} s")

        plt.xlabel("Posizione (m)")

        plt.ylabel("observable")

        plt.yscale('log')

        plt.grid()

        plt.legend()

        plt.show()
 
# Creazione della colormap

time = np.arange(Nt) * dt

x = np.linspace(0, Ly, Ny)
 
plt.figure(figsize=(8,10))

plt.imshow(Eyg_history, aspect='auto', extent=[0, Ly, 0, Nt * dt], origin='lower', cmap='RdBu')

plt.colorbar(label='Campo Elettrico (V/m)')

plt.ylabel("Tempo (s)")

plt.xlabel("Posizione (m)")

plt.title("Evoluzione Temporale e Spaziale del Campo Elettrico")

plt.show()
 
# calcola lo spettro omega(k) dell'oscillazione del campo elettrico

from scipy.fft import fft, fftfreq
 
# Trasformata di Fourier bidimensionale

E_fft = np.fft.fft2(Eyg_history)
 
# Frequenze spaziali e temporali

ky = np.fft.fftfreq(Ny, d=dy)

omega = np.fft.fftfreq(Nt, d=dt)
 
# Prendere solo le frequenze positive

ky_pos = ky[ky >= 0]

omega_pos = omega[omega >= 0]

E_fft_pos = E_fft[:len(omega_pos), :len(ky_pos)]
 
# Calcolo del modulo dello spettro per le frequenze positive

omega_k_pos = np.abs(E_fft_pos)
 
# Plot dello spettro bidimensionale (frequenze positive)

plt.figure(figsize=(10, 6))

plt.contourf(ky_pos, omega_pos, omega_k_pos, levels=50, cmap="viridis")

plt.colorbar(label="$|\hat{E}(\omega, k)|$")

plt.title("Spettro $\omega(k)$ (frequenze positive)")

plt.xlabel("Frequenze spaziali $k$")

plt.ylabel("Frequenze temporali $\omega$")

# definire la scala delle y

plt.ylim(1e9, 2e10)

# definire la scala delle x

plt.xlim(1e1, 1e3)

plt.grid(True)

plt.show()
Google Colab
 